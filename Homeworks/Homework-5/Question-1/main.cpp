/* 
 * Question 1: Human Activity Recognition (Data Injection Mode)
 * Platform: Mbed OS
 */

#include "mbed.h"
#include "har_feature_extraction.h"
#include "lib_model.h"
#include "lib_serial.h"

// Include the file generated by your main.py
// Ensure the filename matches what main.py produced
#include "har_mlp.h" 

// --- Constants ---
// WISDM dataset uses 20Hz sampling. Window is usually ~4-5 seconds.
// Ensure VECTOR_LEN matches what your model was trained with (usually 64 or 80 or 128)
#define VECTOR_LEN 80 
#define NUM_AXES 3
#define NUM_CLASSES 6

// --- Globals ---
// Input buffer to hold raw accelerometer data received from PC
// 3 axes (x, y, z) * VECTOR_LEN samples
float acc_input_buffer[NUM_AXES][VECTOR_LEN];

// Structure to hold extracted features (Mean, StdDev, etc.)
HAR_FtrExtOutput features;

// TensorFlow Lite Micro Tensors
TfLiteTensor* input = nullptr;
TfLiteTensor* output = nullptr;

// Tensor Arena (Memory pool for Neural Network operations)
// Increased size to be safe, adjust if you hit memory limits
constexpr int kTensorArenaSize = 60 * 1024;
alignas(16) static uint8_t tensor_arena[kTensorArenaSize];

int main() {
    // 1. Initialize Serial Communication
    // USBTX/USBRX connects to the PC via the USB cable
    LIB_SERIAL_Init(USBTX, USBRX);

    // 2. Initialize TensorFlow Lite Model
    // 'har_mlp' is the variable name inside har_mlp.h generated by your python script
    // 'har_mlp_len' is the length variable in that same file
    // Note: If tflite2cc generated different names, update them here.
    if (LIB_MODEL_Init(har_mlp, &input, tensor_arena, kTensorArenaSize) != 0) {
        // Init failed (Blink LED or print error if possible)
        return -1;
    }

    while (true) {
        // ---------------------------------------------------------
        // A. Receive Offline Data from PC
        // ---------------------------------------------------------
        // The MCU waits here until Python sends a chunk of data.
        // We expect 3 floats * VECTOR_LEN (e.g., 3 * 80 = 240 floats)
        LIB_SERIAL_Receive(acc_input_buffer, NUM_AXES * VECTOR_LEN, TYPE_F32);

        // ---------------------------------------------------------
        // B. Extract Features (DSP)
        // ---------------------------------------------------------
        // Calculate Mean, StdDev, FFT Energy, etc. on the MCU
        har_extract_features(acc_input_buffer, &features);

        // ---------------------------------------------------------
        // C. Prepare Neural Network Input
        // ---------------------------------------------------------
        // The model expects a flat array of features. 
        // We copy the memory of the feature struct directly to the input tensor.
        memcpy(input->data.f, &features, sizeof(HAR_FtrExtOutput));

        // ---------------------------------------------------------
        // D. Run Inference
        // ---------------------------------------------------------
        LIB_MODEL_Run(&output);

        // ---------------------------------------------------------
        // E. Send Results to PC
        // ---------------------------------------------------------
        // Send the array of probabilities (6 floats) back to the Python script
        LIB_SERIAL_Transmit(output->data.f, NUM_CLASSES, TYPE_F32);
    }
}